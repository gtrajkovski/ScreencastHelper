"""AI action handlers for buttons."""

import re
from dataclasses import dataclass
from typing import Dict
from .client import AIClient
from .prompts import (
    SCRIPT_GENERATOR, TTS_OPTIMIZER, DEMO_GENERATOR,
    DATA_GENERATOR, ALIGNMENT_CHECKER, QUALITY_CHECKER
)
from ..config import Config


@dataclass
class ActionResult:
    """Result from an AI action."""
    success: bool
    output: str
    artifacts: Dict[str, str]  # filename -> content
    message: str


class AIActions:
    """Handler for AI action buttons."""

    def __init__(self):
        self.client = AIClient()
        self.current_project: Dict = {}

    def generate_full_package(
        self,
        topic: str,
        bullets: str,
        duration: int,
        demo_requirements: str
    ) -> ActionResult:
        """Generate complete screencast package."""

        artifacts = {}

        # 1. Generate script
        script = self._generate_script(topic, bullets, duration)
        artifacts["narration_script.md"] = script

        # 2. Generate TTS version
        tts = self._optimize_tts(script)
        artifacts["narration_tts.txt"] = tts

        # 3. Generate demo code
        demo = self._generate_demo(script, demo_requirements, topic)
        artifacts["demo.py"] = demo

        # 4. Generate sample data
        data_code = self._generate_data(demo_requirements)
        artifacts["generate_data.py"] = data_code

        # 5. Generate run script
        run_script = self._generate_run_script(topic)
        artifacts["run_demo.bat"] = run_script

        # Store in project
        self.current_project = {
            "topic": topic,
            "bullets": bullets,
            "duration": duration,
            "demo_requirements": demo_requirements,
            "artifacts": artifacts
        }

        return ActionResult(
            success=True,
            output=script,  # Show script in preview
            artifacts=artifacts,
            message=f"Generated full package: {len(artifacts)} files"
        )

    def _generate_script(self, topic: str, bullets: str, duration: int) -> str:
        """Generate narration script."""
        target_words = duration * Config.WORDS_PER_MINUTE

        prompt = f"""Create a {duration}-minute narration script (~{target_words} words) for a technical screencast.

Topic: {topic}

Bullet Points:
{bullets}

Format with these sections:
## HOOK
## OBJECTIVE
## CONTENT
## SUMMARY
## CALL TO ACTION

Include [visual cues] and [PAUSE] markers throughout."""

        return self.client.generate(SCRIPT_GENERATOR, prompt)

    def _optimize_tts(self, script: str) -> str:
        """Optimize script for TTS."""
        # First apply config replacements
        tts_text = script
        for original, replacement in Config.TTS_FIXES.items():
            tts_text = tts_text.replace(original, replacement)

        # Then AI cleanup
        prompt = f"""Optimize this script for text-to-speech:

{tts_text}

Remove [visual cues], keep [PAUSE], ensure natural pronunciation."""

        return self.client.generate(TTS_OPTIMIZER, prompt, max_tokens=8192)

    def _generate_demo(self, script: str, requirements: str, topic: str) -> str:
        """Generate interactive demo code."""
        prompt = f"""Create an interactive Python demo for this screencast:

TOPIC: {topic}

NARRATION SCRIPT:
{script}

DEMO REQUIREMENTS:
{requirements}

Create a complete, runnable Python script with:
1. Section headers matching the script
2. Narration prompts before each action
3. ENTER pauses between sections
4. Colorful terminal output
5. Actual working code (not pseudocode)

Include all imports and a main() function."""

        return self.client.generate(DEMO_GENERATOR, prompt, max_tokens=8192)

    def _generate_data(self, requirements: str) -> str:
        """Generate data creation code."""
        prompt = f"""Create Python code to generate sample data for this demo:

Requirements:
{requirements}

Generate code that:
1. Creates realistic CSV files
2. Uses appropriate data sizes for demo
3. Includes intentional issues if needed for the demo
4. Saves to a 'data/' directory

Output complete, runnable Python code."""

        return self.client.generate(DATA_GENERATOR, prompt)

    def _generate_run_script(self, topic: str) -> str:
        """Generate Windows batch run script."""
        return f'''@echo off
REM {topic} - Interactive Screencast Demo
REM Generated by ScreenCast Studio

cd /d "%~dp0"

echo ======================================
echo   {topic.upper()[:40]}
echo ======================================
echo.
echo Press ENTER to advance through each step.
echo Press Ctrl+C to exit.
echo.
pause

REM Generate data if needed
if not exist "data" (
    echo Generating sample data...
    python generate_data.py
)

REM Run the demo
python demo.py
'''

    def check_alignment(self) -> ActionResult:
        """Check alignment between script and demo."""
        if not self.current_project.get("artifacts"):
            return ActionResult(
                success=False,
                output="",
                artifacts={},
                message="No project loaded. Generate a package first."
            )

        script = self.current_project["artifacts"].get("narration_script.md", "")
        demo = self.current_project["artifacts"].get("demo.py", "")

        prompt = f"""Check alignment between this script and demo:

SCRIPT:
{script}

DEMO CODE:
{demo}

Verify:
1. Each script section has corresponding demo section
2. Visual cues match demo actions
3. Timing is realistic
4. All concepts in script are demonstrated

Output alignment report with checkmarks/X marks and suggestions."""

        report = self.client.generate(ALIGNMENT_CHECKER, prompt)

        self.current_project["artifacts"]["alignment_report.md"] = report

        return ActionResult(
            success=True,
            output=report,
            artifacts={"alignment_report.md": report},
            message="Alignment check complete"
        )

    def check_quality(self) -> ActionResult:
        """Run quality checks on package."""
        if not self.current_project.get("artifacts"):
            return ActionResult(
                success=False,
                output="",
                artifacts={},
                message="No project loaded. Generate a package first."
            )

        all_content = "\n\n---\n\n".join([
            f"FILE: {name}\n{content}"
            for name, content in self.current_project["artifacts"].items()
        ])

        prompt = f"""Run quality checks on this screencast package:

{all_content}

Check:
1. Script quality (hook, objectives, content, summary, CTA)
2. TTS readiness (pronunciation, flow)
3. Demo quality (runnable, visual, timed)
4. Data quality (realistic, appropriate)

Output detailed quality report with scores and improvements."""

        report = self.client.generate(QUALITY_CHECKER, prompt)

        self.current_project["artifacts"]["quality_report.md"] = report

        return ActionResult(
            success=True,
            output=report,
            artifacts={"quality_report.md": report},
            message="Quality check complete"
        )

    def regenerate_section(self, section: str, feedback: str) -> ActionResult:
        """Regenerate a specific section with feedback."""
        if not self.current_project.get("artifacts"):
            return ActionResult(
                success=False,
                output="",
                artifacts={},
                message="No project loaded."
            )

        script = self.current_project["artifacts"].get("narration_script.md", "")

        prompt = f"""Rewrite only the {section} section of this script:

CURRENT SCRIPT:
{script}

FEEDBACK:
{feedback}

Output only the rewritten {section} section, maintaining the same style."""

        new_section = self.client.generate(SCRIPT_GENERATOR, prompt)

        # Update script with new section
        pattern = f"## {section}.*?(?=## |$)"
        updated_script = re.sub(
            pattern,
            f"## {section}\n\n{new_section}\n\n",
            script,
            flags=re.DOTALL
        )

        self.current_project["artifacts"]["narration_script.md"] = updated_script

        return ActionResult(
            success=True,
            output=updated_script,
            artifacts={"narration_script.md": updated_script},
            message=f"Regenerated {section} section"
        )

    def export_all(self, output_dir: str) -> ActionResult:
        """Export all artifacts to directory."""
        from pathlib import Path

        if not self.current_project.get("artifacts"):
            return ActionResult(
                success=False,
                output="",
                artifacts={},
                message="No project loaded."
            )

        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        for filename, content in self.current_project["artifacts"].items():
            filepath = output_path / filename
            filepath.write_text(content, encoding='utf-8')

        return ActionResult(
            success=True,
            output=f"Exported to {output_path}",
            artifacts={},
            message=f"Exported {len(self.current_project['artifacts'])} files to {output_path}"
        )
