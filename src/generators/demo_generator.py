"""Generate interactive Python demo scripts."""

import re
from typing import List
from dataclasses import dataclass
from ..utils.ai_client import AIClient


@dataclass
class DemoSection:
    """A section of the interactive demo."""
    title: str
    narration: str
    code: str
    pause_message: str = "Press ENTER to continue..."


@dataclass
class GeneratedDemo:
    """Complete generated demo script."""
    code: str
    sections: List[DemoSection]
    required_files: List[str]

    def save(self, filepath: str):
        """Save demo script to file."""
        from pathlib import Path
        Path(filepath).parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(self.code)


class DemoGenerator:
    """Generate interactive Python demo scripts."""

    DEMO_TEMPLATE = '''#!/usr/bin/env python3
"""
Interactive Demo: {title}
Generated by ScreenCast Studio

Usage:
    python {filename}

Controls:
    ENTER - Proceed to next step
    Ctrl+C - Exit demo
"""

import os
import sys
import time
from pathlib import Path

# Optional: rich for colorful output
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.syntax import Syntax
    from rich import print as rprint
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None


def clear_screen():
    """Clear terminal screen."""
    os.system('cls' if os.name == 'nt' else 'clear')


def pause(message: str = "Press ENTER to continue..."):
    """Pause execution and wait for user input."""
    input(f"\\n   [{{message}}]")


def print_narration(text: str):
    """Print narration text prominently."""
    if RICH_AVAILABLE:
        console.print(Panel(text, title="NARRATION", border_style="blue"))
    else:
        print(f"\\n{{'='*60}}")
        print("NARRATION:")
        print(text)
        print('='*60)


def print_section(title: str):
    """Print section header."""
    if RICH_AVAILABLE:
        console.rule(f"[bold cyan]{{title}}[/bold cyan]")
    else:
        print(f"\\n{{'#'*60}}")
        print(f"## {{title}}")
        print('#'*60)


def simulate_typing(text: str, delay: float = 0.03):
    """Simulate typing effect for commands."""
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)
    print()


{sections_code}


def main():
    """Run the interactive demo."""
    clear_screen()

    if RICH_AVAILABLE:
        console.print(Panel.fit(
            "[bold]Interactive Demo: {title}[/bold]\\n\\n"
            "Press ENTER to advance through each step.\\n"
            "Press Ctrl+C to exit at any time.",
            border_style="green"
        ))
    else:
        print("=" * 60)
        print("Interactive Demo: {title}")
        print("=" * 60)
        print("\\nPress ENTER to advance through each step.")
        print("Press Ctrl+C to exit at any time.\\n")

    pause("Press ENTER to begin...")

{main_calls}

    if RICH_AVAILABLE:
        console.print("\\n[bold green]Demo complete![/bold green]")
    else:
        print("\\nDemo complete!")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\\n\\nDemo interrupted. Goodbye!")
        sys.exit(0)
'''

    def __init__(self):
        self.ai_client = AIClient()

    def generate(
        self,
        script: str,
        demo_requirements: str,
        title: str = "Demo",
        filename: str = "demo.py"
    ) -> GeneratedDemo:
        """Generate interactive demo from script.

        Args:
            script: Narration script
            demo_requirements: What the demo should show
            title: Demo title
            filename: Output filename

        Returns:
            GeneratedDemo with code and metadata
        """
        # Parse script into sections
        sections = self._parse_script_sections(script)

        # Generate code for each section
        sections_code = []
        main_calls = []

        for i, section in enumerate(sections, 1):
            func_name = f"section_{i}"
            code = self._generate_section_code(section, func_name, demo_requirements)
            sections_code.append(code)
            main_calls.append(f"    {func_name}()")

        # Assemble final demo
        full_code = self.DEMO_TEMPLATE.format(
            title=title,
            filename=filename,
            sections_code="\n\n".join(sections_code),
            main_calls="\n".join(main_calls)
        )

        # Extract required files from code
        required_files = self._extract_required_files(full_code)

        return GeneratedDemo(
            code=full_code,
            sections=sections,
            required_files=required_files
        )

    def _parse_script_sections(self, script: str) -> List[DemoSection]:
        """Parse script into demo sections."""
        sections = []
        # Match ## HEADER followed by content
        pattern = r'## (.*?)\n(.*?)(?=## |$)'

        for match in re.finditer(pattern, script, re.DOTALL):
            title = match.group(1).strip()
            content = match.group(2).strip()

            sections.append(DemoSection(
                title=title,
                narration=content,
                code="",  # Will be generated
                pause_message=f"Press ENTER for: {title}"
            ))

        return sections

    def _generate_section_code(
        self,
        section: DemoSection,
        func_name: str,
        demo_requirements: str
    ) -> str:
        """Generate Python code for a single section."""
        # Truncate narration for display
        narration_preview = section.narration[:500]
        if len(section.narration) > 500:
            narration_preview += "..."

        code = f'''
def {func_name}():
    """Section: {section.title}"""
    print_section("{section.title}")

    print_narration("""
{narration_preview}
""")

    pause("{section.pause_message}")

    # Demo actions for this section
    # TODO: Add specific demo code based on requirements
    print("\\n[Demo actions would go here]\\n")
'''
        return code

    def _extract_required_files(self, code: str) -> List[str]:
        """Extract file paths referenced in code."""
        files = []
        # Match file paths in strings
        patterns = [
            r'["\']([^"\']*\.(?:csv|json|yaml|yml|py|html))["\']',
            r'Path\(["\']([^"\']+)["\']\)',
        ]

        for pattern in patterns:
            matches = re.findall(pattern, code)
            files.extend(matches)

        return list(set(files))

    def generate_with_ai(
        self,
        script: str,
        demo_requirements: str,
        title: str = "Demo"
    ) -> GeneratedDemo:
        """Generate demo using AI for more sophisticated code."""

        # Use AI client to generate full demo
        raw_code = self.ai_client.generate_demo_code(script, demo_requirements)

        # Clean up AI output (remove markdown code blocks if present)
        code = re.sub(r'^```python\n?', '', raw_code)
        code = re.sub(r'\n?```$', '', code)

        return GeneratedDemo(
            code=code,
            sections=[],  # AI generates integrated code
            required_files=self._extract_required_files(code)
        )
